# 变量和基本类型

## **对象**
> 具有某种数据类型的内存空间

## **extern**
> 在函数体内部，初始化一个由extern关键字标记的变量，将引发错误  

## **引用**
> 引用不是对象  
> 必须初始化，并且无法重新绑定到另外一个对象    
> 类型要严格匹配

## **指针**
> 指针是对象    
> 不能把int变量赋给指针，即使int变量的值恰好等于0   

**void\* 指针**
> 可用于存放任意对象的地址  
> 和别的指针做比较、作为函数的输入输出  
> 只能存，不能访问、操作

## **const**
> const 对象必须初始化   
> 默认状态下，const 只在文件内有效 (可以用 extern 关键字解决)   

**const 的引用**
> （没有规定所引用对象必须是常量）
> 可以绑定字面量
```C++
const int& r1 = 42;
```
> 当引用被绑定到另外一个类型上时，会生成临时量，绑定到临时量上，只能用 const 引用   
```C++
double dv = 3.14;
const int& r1 = dv; // good
int& r2 = dv;       // wrong
```
**指针和 const**    
> 指向常量的指针（不能修改值） ` const int* a = 0`   （没有规定所指对象必须是常量）  
> 常量指针（不能修改指向） `int* const p = 0`

+ 顶层 const 
  + 表示指针本身是常量
  + 更一般的，表示任意对象是常量，这一点对任何数据类型都适用
+ 底层 const
  + 表示所指对象是常量
  + 与指针和引用等复合类型的基本类型部分有关

**constexpr指针**
> constexpr 仅对指针有效（顶层 const），即常量指针，不能修改指向

**类型别名**
```C++
typedef char *pstring
const pstring cstr = 0  // 指向char的常量指针
const char * cstr = 0;  // 指向常量的指针
// 所以并不是简单替换，pstring的基本类型是指针，重写以后char是基本类型
```
**auto**
> auto 一般会忽略掉顶层 const（指针本身是常量），底层 const会被保留下来  
> 如果希望是顶层 const，需要明确指出 `const auto f = a`

**decltype**
> 从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化（与 auto 相比）  
> 如果 `decltype` 使用的表达式是变量，则返回该变量的类型（包括顶层 const 和引用在内）  
> **`decltype(*p)` 的结果类型是引用**  
> **`decltype((variable))` 的结果永远是引用**

